<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCPé€šä¿¡é…ç½® - CABM</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="stylesheet" href="/static/css/sci-fi-theme.css">
    <link rel="stylesheet" href="/static/css/continue-prompt.css">
    <link rel="stylesheet" href="/static/css/tcp-modern.css">
    <style>
        /* ä»…åœ¨TCPé…ç½®é¡µé¢è¦†ç›–å…¨å±€å¸ƒå±€ï¼Œæ¢å¤æ»šåŠ¨ */
        .container {
            height: auto !important;
            min-height: 100vh;
            overflow-y: auto !important;
            overflow-x: hidden;
        }

        /* è®©å½“å‰é¡µé¢å‚ä¸æ­£å¸¸æ–‡æ¡£æµå¹¶è‡ªé€‚åº”é«˜åº¦ */
        #tcpPage.page {
            position: relative !important;
            height: auto !important;
            min-height: 100vh;
        }

        /* èƒŒæ™¯é‡‡ç”¨å›ºå®šå®šä½ï¼Œä¸å½±å“å†…å®¹æ»šåŠ¨ */
        .background-container,
        .background-image,
        .background-overlay {
            position: fixed !important;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="tcpPage" class="page active">
            <div class="background-container">
                <div class="background-image default-background"></div>
                <div class="background-overlay"></div>
            </div>

            <div class="tcp-modern-container">
                <div class="tcp-modern-header">
                    <a href="/" class="btn back-btn">è¿”å›</a>
                    <h2>CABM - TCPé€šä¿¡é…ç½®</h2>
                </div>

                <!-- ç™»å½•éƒ¨åˆ† -->
                <div class="tcp-modern-card">
                    <h3>OpenFrp ç™»å½•</h3>

                    <!-- TCPè¿æ¥ä¿¡æ¯æ˜¾ç¤ºåŒºåŸŸ -->
                    <div id="tunnelInfo" class="tcp-modern-info-panel" style="display: none;">
                        <h4>ğŸŒ TCPé€šé“å·²åˆ›å»º</h4>
                        <p id="tunnelAddress">æ­£åœ¨è·å–è¿æ¥åœ°å€...</p>
                        <div class="tcp-modern-info-note">
                            <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong>æ‚¨å¯ä»¥é€šè¿‡ä»¥ä¸Šåœ°å€è®¿é—®CABMæœåŠ¡ï¼Œè¿œç¨‹ç«¯å£ä¼šè‡ªåŠ¨ç”Ÿæˆå¹¶éšæœºåˆ†é…ã€‚
                        </div>
                    </div>

                    <div id="loginStatus" class="tcp-modern-message" style="display: none;"></div>
                    <div class="tcp-modern-form-group">
                        <label for="token">ç”¨æˆ·Token:</label>
                        <input type="password" id="token" class="tcp-modern-form-control" placeholder="è¾“å…¥æ‚¨çš„OpenFrpç”¨æˆ·token" autocomplete="off">
                        <small class="tcp-modern-help-text">
                            è·å–token: ç™»å½•OpenFrpæ§åˆ¶å° â†’ ä¸ªäººä¸­å¿ƒ â†’ ç¬¬ä¸‰æ–¹å®¢æˆ·ç«¯å®‰å…¨ç™»å½•
                        </small>
                    </div>
                    <div class="tcp-modern-btn-group">
                        <button id="loginBtn" class="tcp-modern-btn tcp-modern-btn-primary">ç™»å½•</button>
                        <button id="checkStatusBtn" class="tcp-modern-btn tcp-modern-btn-secondary">æ£€æŸ¥çŠ¶æ€</button>
                        <button id="testFrpcBtn" class="tcp-modern-btn tcp-modern-btn-info" style="display: none;">æµ‹è¯•Frpc</button>
                        <button id="checkRestartBtn" class="tcp-modern-btn tcp-modern-btn-warning" style="display: none;">æ£€æŸ¥å¹¶é‡å¯</button>
                    </div>
                    <div id="loginInfo" class="tcp-modern-info-panel">
                        <h4>â„¹â„¹ï¸ ä½¿ç”¨è¯´æ˜</h4>
                        <ul>
                            <li>Tokenæ˜¯æ‚¨è®¿é—®OpenFrp APIçš„å¯†é’¥ï¼Œè¯·å¦¥å–„ä¿ç®¡</li>
                            <li>ç™»å½•åç³»ç»Ÿå°†è‡ªåŠ¨åˆ›å»ºCABMTCPTUNNELï¼Œå®ç°ç½‘ç»œç©¿é€</li>
                            <li>ä¸åŒç½‘ç»œçš„è®¾å¤‡å¯ä»¥é€šè¿‡ç”Ÿæˆçš„è¿œç¨‹ç«¯å£è®¿é—®æ‚¨çš„CABMæœåŠ¡</li>
                        </ul>
                    </div>
                </div>

                <!-- åˆ›å»ºéš§é“éƒ¨åˆ† -->
                <div class="tcp-modern-card" id="createSection" style="display: none;">
                    <h3>åˆ›å»ºTCPéš§é“</h3>
                    <div id="createMessage" class="tcp-modern-message" style="display: none;"></div>
                    <div class="tcp-modern-info-panel">
                        <h4>â„¹ï¸ è‡ªåŠ¨é…ç½®è¯´æ˜</h4>
                        <ul>
                            <li>éš§é“åç§°ï¼šå›ºå®šä¸º <strong>CABMTCPTUNNEL</strong></li>
                            <li>æœ¬åœ°ç«¯å£ï¼šè‡ªåŠ¨ä½¿ç”¨CABMè¿è¡Œç«¯å£ <strong>5000</strong></li>
                            <li>è¿œç¨‹ç«¯å£ï¼šè‡ªåŠ¨ç”Ÿæˆéšæœºç«¯å£</li>
                            <li>èŠ‚ç‚¹é€‰æ‹©ï¼šä¼˜å…ˆ '#9 ä¹‰ä¹Œç”µä¿¡ğŸ˜°'ï¼Œå¦åˆ™é€‰æ‹©ç¬¬ä¸€ä¸ªå¯ç”¨èŠ‚ç‚¹ã€‚<br/>å¯ç”¨æ¡ä»¶ï¼šstatus == 200 ä¸” é fullyLoadedã€‚</li>
                        </ul>
                    </div>
                    <button id="createTunnelBtn" class="tcp-modern-btn tcp-modern-btn-primary">åˆ›å»ºCABMTCPTUNNEL</button>
                </div>

                <!-- éš§é“åˆ—è¡¨éƒ¨åˆ† -->
                <div class="tcp-modern-card" id="tunnelListSection" style="display: none;">
                    <div class="tcp-modern-tunnel-header">
                        <h3>éš§é“åˆ—è¡¨</h3>
                        <div class="tcp-modern-tunnel-actions-header">
                            <button id="refreshTunnelsBtn" class="tcp-modern-btn tcp-modern-btn-secondary">åˆ·æ–°åˆ—è¡¨</button>
                        </div>
                    </div>
                    <div id="tunnelList" class="tcp-modern-tunnel-list">
                        <!-- éš§é“åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€åŠ è½½ -->
                    </div>
                </div>
            </div>
        </div>

        <!-- æ¨¡æ€æ¡† -->
        <div class="modal" id="confirmModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>ç¡®è®¤</h3>
                    <button id="closeConfirmButton" class="btn close-btn">&times;</button>
                </div>
                <div class="modal-body">
                    <p id="confirmMessage">ç¡®å®šè¦æ‰§è¡Œæ­¤æ“ä½œå—ï¼Ÿ</p>
                    <div class="confirm-buttons">
                        <button id="confirmYesButton" class="btn primary-btn">ç¡®å®š</button>
                        <button id="confirmNoButton" class="btn secondary-btn">å–æ¶ˆ</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- åŠ è½½æŒ‡ç¤ºå™¨ -->
        <div class="loading-container" id="loadingIndicator">
            <div class="loading-spinner"></div>
            <p>å¤„ç†ä¸­...</p>
        </div>

        <!-- é”™è¯¯å®¹å™¨ -->
        <div class="error-container" id="errorContainer">
            <p id="errorMessage"></p>
            <button id="errorCloseButton" class="btn">å…³é—­</button>
        </div>
    </div>

    <script>
        class TCPManager {
            constructor() {
                this.selectedNodeId = null;
                this.runningProcesses = {}; // è·Ÿè¸ªè¿è¡Œä¸­çš„è¿›ç¨‹
                this.init();
            }

            init() {
                this.bindEvents();
                this.checkLoginStatus();
                this.bindModalEvents();
            }

            bindEvents() {
                // ç™»å½•ç›¸å…³
                document.getElementById('loginBtn').addEventListener('click', () => this.login());
                document.getElementById('checkStatusBtn').addEventListener('click', () => this.checkLoginStatus());
                document.getElementById('testFrpcBtn').addEventListener('click', () => this.testFrpc());
                document.getElementById('checkRestartBtn').addEventListener('click', () => this.checkAndRestartTunnel());

                // éš§é“ç›¸å…³
                document.getElementById('createTunnelBtn').addEventListener('click', () => this.createTunnel());
                document.getElementById('refreshTunnelsBtn').addEventListener('click', () => this.loadTunnels());
            }

            bindModalEvents() {
                // ç¡®è®¤æ¨¡æ€æ¡†
                document.getElementById('closeConfirmButton').addEventListener('click', () => this.closeConfirmModal());
                document.getElementById('confirmNoButton').addEventListener('click', () => this.closeConfirmModal());

                // é”™è¯¯å®¹å™¨
                document.getElementById('errorCloseButton').addEventListener('click', () => this.closeError());
            }

            async login() {
                const token = document.getElementById('token').value.trim();
                const loginBtn = document.getElementById('loginBtn');

                if (!token) {
                    this.showMessage('loginStatus', 'âŒâŒ è¯·è¾“å…¥ç”¨æˆ·token', 'error');
                    document.getElementById('token').focus();
                    return;
                }

                if (token.length < 10) {
                    this.showMessage('loginStatus', 'âŒâŒ Tokenæ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·æ£€æŸ¥', 'error');
                    return;
                }

                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                loginBtn.disabled = true;
                loginBtn.textContent = 'ç™»å½•ä¸­...';

                try {
                    const response = await fetch('/api/tcp/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const result = await response.json();
                    if (result.success) {
                        this.showMessage('loginStatus', 'âœ… ç™»å½•æˆåŠŸï¼', 'success');
                        this.showCreateSection();
                         await this.loadTunnels();

                         // æ˜¾ç¤ºæ£€æŸ¥ã€æµ‹è¯•å’Œé‡å¯æŒ‰é’®
                         document.getElementById('testFrpcBtn').style.display = 'inline-block';
                         document.getElementById('checkRestartBtn').style.display = 'inline-block';

                        // éšè—ä½¿ç”¨è¯´æ˜ï¼Œæ˜¾ç¤ºæˆåŠŸä¿¡æ¯
                        document.getElementById('loginInfo').style.display = 'none';
                    } else {
                        this.showMessage('loginStatus', 'âŒâŒ ' + (result.error || 'ç™»å½•å¤±è´¥ï¼Œè¯·æ£€æŸ¥token'), 'error');
                        // æ˜¾ç¤ºä½¿ç”¨è¯´æ˜å¸®åŠ©ç”¨æˆ·
                        document.getElementById('loginInfo').style.display = 'block';
                    }
                } catch (error) {
                    console.error('ç™»å½•é”™è¯¯:', error);
                    this.showMessage('loginStatus', 'âŒâŒ ç½‘ç»œé”™è¯¯: ' + error.message, 'error');
                    document.getElementById('loginInfo').style.display = 'block';
                } finally {
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    loginBtn.disabled = false;
                    loginBtn.textContent = 'ç™»å½•';
                }
            }

            async checkLoginStatus() {
                const checkBtn = document.getElementById('checkStatusBtn');
                checkBtn.disabled = true;
                checkBtn.textContent = 'æ£€æŸ¥ä¸­...';

                try {
                    const response = await fetch('/api/tcp/status');
                    const result = await response.json();

                    if (result.success && result.is_logged_in) {
                        this.showMessage('loginStatus', 'âœ… å·²ç™»å½•åˆ°OpenFrp', 'success');
                        this.showCreateSection();
                         await this.loadTunnels();

                         // æ˜¾ç¤ºæ£€æŸ¥ã€æµ‹è¯•å’Œé‡å¯æŒ‰é’®
                         document.getElementById('testFrpcBtn').style.display = 'inline-block';
                         document.getElementById('checkRestartBtn').style.display = 'inline-block';

                        document.getElementById('loginInfo').style.display = 'none';
                    } else {
                        this.showMessage('loginStatus', 'âŒâŒ æœªç™»å½•ï¼Œè¯·å…ˆç™»å½•', 'error');
                        document.getElementById('loginInfo').style.display = 'block';
                    }
                } catch (error) {
                    console.error('æ£€æŸ¥çŠ¶æ€é”™è¯¯:', error);
                    this.showMessage('loginStatus', 'âŒâŒ æ£€æŸ¥çŠ¶æ€å¤±è´¥: ' + error.message, 'error');
                } finally {
                    checkBtn.disabled = false;
                    checkBtn.textContent = 'æ£€æŸ¥çŠ¶æ€';
                }
            }

            async loadNodes() {
                try {
                    const response = await fetch('/api/tcp/nodes');
                    const result = await response.json();
                    if (result.success) {
                        this.renderNodes(result.data.list);
                    } else {
                        console.error('åŠ è½½èŠ‚ç‚¹å¤±è´¥:', result.error);
                    }
                } catch (error) {
                    console.error('åŠ è½½èŠ‚ç‚¹å¤±è´¥:', error);
                }
            }

            renderNodes(nodes) {
                const nodeList = document.getElementById('nodeList');
                nodeList.innerHTML = '';

                nodes.forEach(node => {
                    if (node.status !== 200) return; // åªæ˜¾ç¤ºæ­£å¸¸èŠ‚ç‚¹

                    const nodeItem = document.createElement('div');
                    nodeItem.className = 'tcp-modern-node-item';
                    nodeItem.innerHTML = `
                        <strong>${node.name}</strong>
                        <small>${node.hostname || 'åœ°å€æœªå…¬å¼€'} | å¸¦å®½: ${node.bandwidth}M</small>
                    `;
                    nodeItem.addEventListener('click', () => this.selectNode(node.id, nodeItem));
                    nodeList.appendChild(nodeItem);
                });
            }

            selectNode(nodeId, element) {
                // æ¸…é™¤ä¹‹å‰é€‰æ‹©
                document.querySelectorAll('.tcp-modern-node-item').forEach(item => {
                    item.classList.remove('selected');
                });

                // é€‰æ‹©å½“å‰èŠ‚ç‚¹
                element.classList.add('selected');
                this.selectedNodeId = nodeId;
            }

            async createTunnel() {
                try {
                    const response = await fetch('/api/tcp/create', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            local_addr: '127.0.0.1',
                            local_port: 5000  // CABMé»˜è®¤ç«¯å£
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        this.showMessage('createMessage', 'CABMTCPTUNNELåˆ›å»ºæˆåŠŸ', 'success');
                        this.loadTunnels();
                        this.updateTunnelInfo();
                    } else {
                        this.showMessage('createMessage', result.error, 'error');
                    }
                } catch (error) {
                    this.showMessage('createMessage', 'åˆ›å»ºå¤±è´¥: ' + error.message, 'error');
                }
            }

            async loadTunnels() {
                try {
                    const response = await fetch('/api/tcp/tunnels');
                    const result = await response.json();

                    if (result.success) {
                        if (result.data && result.data.list) {
                            this.renderTunnels(result.data.list);
                            // æ£€æŸ¥æ˜¯å¦æœ‰CABMTCPTUNNELï¼Œå¦‚æœæœ‰åˆ™æ˜¾ç¤ºè¿æ¥ä¿¡æ¯
                            const hasCabmTunnel = result.data.list.some(tunnel => tunnel.proxyName === 'CABMTCPTUNNEL');
                            if (hasCabmTunnel) {
                                this.updateTunnelInfo();
                            } else {
                                document.getElementById('tunnelInfo').style.display = 'none';
                            }
                        } else {
                            this.renderTunnels([]);
                            document.getElementById('tunnelInfo').style.display = 'none';
                        }
                    } else {
                        console.error('åŠ è½½éš§é“å¤±è´¥:', result.error);
                        this.showMessage('tunnelList', 'åŠ è½½éš§é“å¤±è´¥: ' + result.error, 'error');
                        document.getElementById('tunnelInfo').style.display = 'none';
                    }
                } catch (error) {
                    console.error('åŠ è½½éš§é“å¤±è´¥:', error);
                    this.showMessage('tunnelList', 'åŠ è½½éš§é“å¤±è´¥: ' + error.message, 'error');
                }
            }

            renderTunnels(tunnels) {
                const tunnelList = document.getElementById('tunnelList');
                tunnelList.innerHTML = '';

                if (!tunnels || tunnels.length === 0) {
                    tunnelList.innerHTML = '<p style="color: rgba(255,255,255,0.7); text-align: center;">æš‚æ— éš§é“</p>';
                    return;
                }

                tunnels.forEach(tunnel => {
                    if (tunnel.proxyType !== 'tcp') return; // åªæ˜¾ç¤ºTCPéš§é“

                    const tunnelItem = document.createElement('div');
                    tunnelItem.className = 'tcp-modern-tunnel-item';

                    // æ”¹è¿›çš„çŠ¶æ€æ˜¾ç¤ºé€»è¾‘
                    let statusClass, statusText;
                    if (tunnel.online) {
                        statusClass = 'tcp-modern-status-online';
                        statusText = 'åœ¨çº¿';
                    } else {
                        // æ£€æŸ¥æ˜¯å¦æœ‰æœ¬åœ°è¿›ç¨‹åœ¨è¿è¡Œ
                        const isRunning = this.runningProcesses && this.runningProcesses[tunnel.id];
                        if (isRunning) {
                            statusClass = 'tcp-modern-status-connecting';
                            statusText = 'è¿æ¥ä¸­...';
                        } else {
                            statusClass = 'tcp-modern-status-offline';
                            statusText = 'ç¦»çº¿';
                        }
                    }

                    tunnelItem.innerHTML = `
                        <div class="tcp-modern-tunnel-info">
                            <strong>${tunnel.proxyName}</strong>
                            <small>
                                <span class="tcp-modern-status">
                                    <span class="tcp-modern-status-indicator ${statusClass}"></span>${statusText}
                                </span>
                                æœ¬åœ°: ${tunnel.localIp}:${tunnel.localPort} | è¿œç¨‹: ${tunnel.remotePort}
                            </small>
                        </div>
                        <div class="tcp-modern-tunnel-actions">
                            <button class="tcp-modern-action-btn tcp-modern-action-btn-start" onclick="tcpManager.startTunnel(${tunnel.id})">å¯åŠ¨</button>
                            <button class="tcp-modern-action-btn tcp-modern-action-btn-stop" onclick="tcpManager.stopTunnel(${tunnel.id})">åœæ­¢</button>
                            <button class="tcp-modern-action-btn tcp-modern-action-btn-delete" onclick="tcpManager.removeTunnel(${tunnel.id})">åˆ é™¤</button>
                        </div>
                    `;

                    tunnelList.appendChild(tunnelItem);
                });
            }

            async startTunnel(proxyId) {
                try {
                    // æ ‡è®°ä¸ºå¯åŠ¨ä¸­
                    this.runningProcesses[proxyId] = true;

                    const response = await fetch(`/api/tcp/start/${proxyId}`, { method: 'POST' });
                    const result = await response.json();

                    if (result.success) {
                        alert('å¯åŠ¨æˆåŠŸ: ' + result.message);

                        // å¯åŠ¨æˆåŠŸï¼Œåˆ·æ–°éš§é“åˆ—è¡¨
                        this.loadTunnels();

                        // è®¾ç½®å®šæ—¶å™¨æ£€æŸ¥è¿æ¥çŠ¶æ€
                        setTimeout(() => {
                            this.checkTunnelConnection(proxyId);
                        }, 5000); // 5ç§’åæ£€æŸ¥

                    } else {
                        // å¯åŠ¨å¤±è´¥ï¼Œæ¸…é™¤æ ‡è®°
                        delete this.runningProcesses[proxyId];
                        alert('å¯åŠ¨å¤±è´¥: ' + result.error);
                        this.loadTunnels();
                    }
                } catch (error) {
                    // å¯åŠ¨å¤±è´¥ï¼Œæ¸…é™¤æ ‡è®°
                    delete this.runningProcesses[proxyId];
                    alert('å¯åŠ¨å¤±è´¥: ' + error.message);
                    this.loadTunnels();
                }
            }

            async checkTunnelConnection(proxyId) {
                try {
                    const response = await fetch(`/api/tcp/status/${proxyId}`);
                    const result = await response.json();

                    if (result.success) {
                        if (result.status === 'online') {
                            // è¿æ¥æˆåŠŸ
                            delete this.runningProcesses[proxyId];
                            this.loadTunnels();
                            this.showMessage('tunnelList', 'âœ… éš§é“è¿æ¥æˆåŠŸï¼', 'success');
                        } else if (result.status === 'running') {
                            // ä»åœ¨è¿æ¥ä¸­ï¼Œç»§ç»­æ£€æŸ¥
                            setTimeout(() => {
                                this.checkTunnelConnection(proxyId);
                            }, 3000);
                        } else {
                            // è¿æ¥å¤±è´¥
                            delete this.runningProcesses[proxyId];
                            this.loadTunnels();
                            this.showMessage('tunnelList', 'âŒ éš§é“è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥é…ç½®', 'error');
                        }
                    } else {
                        // çŠ¶æ€æ£€æŸ¥å¤±è´¥ï¼Œæ¸…é™¤æ ‡è®°
                        delete this.runningProcesses[proxyId];
                        this.loadTunnels();
                    }
                } catch (error) {
                    console.error('æ£€æŸ¥è¿æ¥çŠ¶æ€å¤±è´¥:', error);
                    delete this.runningProcesses[proxyId];
                    this.loadTunnels();
                }
            }

            async stopTunnel(proxyId) {
                try {
                    const response = await fetch(`/api/tcp/stop/${proxyId}`, { method: 'POST' });
                    const result = await response.json();
                    if (result.success) {
                        alert('åœæ­¢æˆåŠŸ');
                        this.loadTunnels();
                    } else {
                        alert('åœæ­¢å¤±è´¥: ' + result.error);
                    }
                } catch (error) {
                    alert('åœæ­¢å¤±è´¥: ' + error.message);
                }
            }

            async removeTunnel(proxyId) {
                if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªéš§é“å—ï¼Ÿ')) return;

                try {
                    const response = await fetch(`/api/tcp/remove/${proxyId}`, { method: 'DELETE' });
                    const result = await response.json();
                    if (result.success) {
                        alert('åˆ é™¤æˆåŠŸ');
                        this.loadTunnels();
                    } else {
                        alert('åˆ é™¤å¤±è´¥: ' + result.error);
                    }
                } catch (error) {
                    alert('åˆ é™¤å¤±è´¥: ' + error.message);
                }
            }

            showCreateSection() {
                document.getElementById('createSection').style.display = 'block';
                document.getElementById('tunnelListSection').style.display = 'block';
            }

            showMessage(elementId, message, type) {
                const element = document.getElementById(elementId);
                element.innerHTML = message; // ä½¿ç”¨innerHTMLæ”¯æŒè¡¨æƒ…ç¬¦å·
                element.className = `tcp-modern-message tcp-modern-message-${type}`;
                element.style.display = 'block';

                // æ ¹æ®æ¶ˆæ¯ç±»å‹è®¾ç½®ä¸åŒçš„æ˜¾ç¤ºæ—¶é—´
                const duration = type === 'error' ? 8000 : 5000;

                // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
                if (element.hideTimeout) {
                    clearTimeout(element.hideTimeout);
                }

                element.hideTimeout = setTimeout(() => {
                    element.style.display = 'none';
                }, duration);
            }

            // æ¨¡æ€æ¡†æ–¹æ³•
            showConfirmModal(message, onConfirm) {
                document.getElementById('confirmMessage').textContent = message;
                document.getElementById('confirmModal').style.display = 'flex';
                this.confirmCallback = onConfirm;
            }

            closeConfirmModal() {
                document.getElementById('confirmModal').style.display = 'none';
                if (this.confirmCallback) {
                    this.confirmCallback = null;
                }
            }

            // é”™è¯¯å¤„ç†æ–¹æ³•
            showError(message) {
                document.getElementById('errorMessage').textContent = message;
                document.getElementById('errorContainer').style.display = 'block';
            }

            closeError() {
                document.getElementById('errorContainer').style.display = 'none';
            }

            // åŠ è½½æŒ‡ç¤ºå™¨æ–¹æ³•
            showLoading() {
                document.getElementById('loadingIndicator').style.display = 'flex';
            }

            hideLoading() {
                document.getElementById('loadingIndicator').style.display = 'none';
            }

            // æ£€æŸ¥å¹¶é‡å¯éš§é“æ–¹æ³•
            async testFrpc() {
                const btn = document.getElementById('testFrpcBtn');
                const originalText = btn.textContent;
                btn.disabled = true;
                btn.textContent = 'æµ‹è¯•ä¸­...';

                try {
                    const response = await fetch('/api/tcp/test_frpc', { method: 'POST' });
                    const result = await response.json();

                    if (result.success) {
                        this.showMessage('loginStatus', 'âœ… ' + result.message, 'success');
                    } else {
                        this.showMessage('loginStatus', 'âŒâŒ Frpcæµ‹è¯•å¤±è´¥: ' + result.error, 'error');
                    }
                } catch (error) {
                    console.error('æµ‹è¯•frpcé”™è¯¯:', error);
                    this.showMessage('loginStatus', 'âŒâŒ æµ‹è¯•frpcå¤±è´¥: ' + error.message, 'error');
                } finally {
                    btn.disabled = false;
                    btn.textContent = originalText;
                }
            }

            async checkAndRestartTunnel() {
                const btn = document.getElementById('checkRestartBtn');
                const originalText = btn.textContent;
                btn.disabled = true;
                btn.textContent = 'æ£€æŸ¥ä¸­...';

                try {
                    const response = await fetch('/api/tcp/check_restart', { method: 'POST' });
                    const result = await response.json();

                    if (result.success) {
                        if (result.restarted) {
                            this.showMessage('loginStatus', 'âœ… éš§é“å·²é‡å¯', 'success');
                        } else {
                            this.showMessage('loginStatus', 'âœ… éš§é“ç«¯å£åŒ¹é…ï¼Œæ— éœ€é‡å¯', 'success');
                        }
                        this.loadTunnels();
                        this.updateTunnelInfo();
                    } else {
                        this.showMessage('loginStatus', 'âŒâŒ ' + result.error, 'error');
                    }
                } catch (error) {
                    console.error('æ£€æŸ¥é‡å¯é”™è¯¯:', error);
                    this.showMessage('loginStatus', 'âŒâŒ æ£€æŸ¥é‡å¯å¤±è´¥: ' + error.message, 'error');
                } finally {
                    btn.disabled = false;
                    btn.textContent = originalText;
                }
            }

            // æ›´æ–°éš§é“ä¿¡æ¯æ˜¾ç¤º
            async updateTunnelInfo() {
                try {
                    const response = await fetch('/api/tcp/connect_address');
                    const result = await response.json();

                    const tunnelInfo = document.getElementById('tunnelInfo');
                    const tunnelAddress = document.getElementById('tunnelAddress');

                    if (result.success) {
                        tunnelAddress.textContent = `è¿æ¥åœ°å€: ${result.address}`;
                        tunnelInfo.style.display = 'block';
                    } else {
                        tunnelAddress.textContent = 'æš‚æ— å¯ç”¨è¿æ¥åœ°å€';
                        tunnelInfo.style.display = 'none';
                    }
                } catch (error) {
                    console.error('è·å–è¿æ¥åœ°å€å¤±è´¥:', error);
                    document.getElementById('tunnelInfo').style.display = 'none';
                }
            }
        }

        // å…¨å±€å®ä¾‹
        const tcpManager = new TCPManager();

        // å¤„ç†ç¡®è®¤æ¨¡æ€æ¡†çš„ç¡®è®¤æŒ‰é’®
        document.getElementById('confirmYesButton').addEventListener('click', () => {
            if (tcpManager.confirmCallback) {
                tcpManager.confirmCallback();
                tcpManager.closeConfirmModal();
            }
        });
    </script>
    <script src="/static/js/logo.js"></script>
    <script src="/static/js/sci-fi-effects.js"></script>
</body>
</html>